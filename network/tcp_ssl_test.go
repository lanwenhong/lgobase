package network

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/hex"
	"os"
	"strconv"
	"testing"
	"time"

	"github.com/lanwenhong/lgobase/logger"
	"github.com/lanwenhong/lgobase/network"
	"github.com/lanwenhong/lgobase/util"
)

func TestSSlSend1(t *testing.T) {
	ctx := context.WithValue(context.Background(), "trace_id", util.GenXid())
	rootCAData, err := os.ReadFile("root.crt")
	if err != nil {
		t.Fatal(err)
	}

	rootCAs := x509.NewCertPool()
	// 将 PEM 格式的根证书添加到证书池
	succ := rootCAs.AppendCertsFromPEM(rootCAData)
	if succ != true {
		t.Fatal(succ)
	}

	tlsConfig := &tls.Config{
		RootCAs:    rootCAs,                          // 信任的根 CA 池（用于验证服务器证书）
		ServerName: "terminal.uat.planetpayment.com", // 服务器证书的域名（必须与证书的 CN 或 SAN 匹配）
		MinVersion: tls.VersionTLS12,                 // 禁用不安全的 TLS 版本
		// 禁用 InsecureSkipVerify（生产环境绝对不能开启！）
		//InsecureSkipVerify: true, // 开启后会跳过证书验证（不安全）
	}

	cTimeout := 3 * time.Second
	rTimeout := 30 * time.Second
	wTimeout := 30 * time.Second

	logger.Debugf(ctx, "cTimeout: %d", cTimeout)
	c := network.NewTcpSslConn("terminal.uat.planetpayment.com:40860", cTimeout, rTimeout, wTimeout, tlsConfig)
	err = c.Open(ctx)
	if err != nil {
		t.Fatal(err)
	}
	//bcd := "0094600000001002003020058020C080030020000000000005550009370021022600374336680006896670D22022011193265100000F313233343536373831383830303033343433333320202003440061000331325800044941022000064942463945410003494303000349440100034945000003494600000349470000034948000010494C0000702940000850BBEFB74400000000"
	//bcd := "0113600010000002003020058020C082030020000000000005550009970021022600374336680006896670D22022011193265100000F3132333435363738313838303030333434333333202020034402509F260825906395A2142A119F2701809F100706010A03A000009F37048F0956B49F360209AA950500000000009A032510169C01009F02060000000000015F2A020156820220009F1A0201569F3303E0F8C89F3501228407A00000000310109F0902008C9F34031F03029F1E0843415357383332309F03060000000000000061000331325800044941022000064942463945410003494303000349440100034945000003494600000349470000034948000010494C0000702940000850BBEFB74400000000"

	//bcd := "0112600010000002003020058020C082030020000000000005550008880021022600374336680006896670D22022011193265100000F31323334353637383138383030303334343333332020200344259F260825906395A2142A119F2701809F100706010A03A000009F37048F0956B49F360209AA950500000000009A032510169C01009F02060000000000015F2A020156820220009F1A0201569F3303E0F8C89F3501228407A00000000310109F0902008C9F34031F03029F1E0843415357383332309F03060000000000000061000331325800044941022000064942463945410003494303000349440100034945000003494600000349470000034948000010494C0000702940000850BBEFB74400000000"

	bcd := "0112600010000002003020058020C082030020000000000005550008880130022600374336680006896670D22022011193265100000F31323334353637383138383030303334343333332020200344259F260825906395A2142A119F2701809F100706010A03A000009F37048F0956B49F360209AA950500000000009A032510169C01009F02060000000000015F2A020156820220009F1A0201569F3303E0F8C89F3501228407A00000000310109F0902008C9F34031F03029F1E0843415357383332309F03060000000000000061000331325800044941022000064942463945410003494303000349440100034945000003494600000349470000034948000010494C0000702940000850BBEFB74400000000"

	//bcd := "0050600010000008002020010000C000029200000004810226313134313131313131383830303033343433333320202000320010494C00007029400008500018505024504C414E4554245041594D454E5424"
	//bcd := "0050600010000008002020010000C00002A000000004810226313134313131313139393938383830322020202020202000320010494C00007029400008500018505024504C414E4554245041594D454E5424"
	//bcd := "00436000100000080020380100000000029200005293231330570927005200370010494C000000000000000200034B54320018505024504C414E4554245041594D454E5424"
	//bcd := "0050600010000008002020010000C000029200000009000226313134313131313131383830303033343433333320202000320010494C00007029400008500018505024504C414E4554245041594D454E5424"
	//bcd := "86080020380100000000029200005293231330570927005200370010494C000000000000000200034B54320018505024504C414E4554245041594D454E5424"
	b, _ := hex.DecodeString(bcd)
	c.Writen(ctx, b)

	head, err := c.Readn(ctx, 2)
	if err != nil {
		t.Fatal(err)
	}

	slen := hex.EncodeToString(head)
	logger.Debugf(ctx, "slen: %s", slen)
	blen, err := strconv.ParseUint(slen, 16, 32)
	if err != nil {
		logger.Warnf(ctx, "err: %s", err.Error())
		return
	}
	logger.Debugf(ctx, "blen: %d", blen)
	data, err := c.Readn(ctx, int(blen))

	if err != nil {
		t.Fatal(err)
	}
	bcdData := hex.EncodeToString(data)
	logger.Debugf(ctx, "bcdData: %s", bcdData)
	c.Close(ctx)
	c.Close(ctx)
	c.Close(ctx)

}

func TestSSlSendMulti(t *testing.T) {

	ctx := context.WithValue(context.Background(), "trace_id", util.GenXid())
	rootCAData, err := os.ReadFile("root.crt")
	if err != nil {
		t.Fatal(err)
	}

	rootCAs := x509.NewCertPool()
	// 将 PEM 格式的根证书添加到证书池
	succ := rootCAs.AppendCertsFromPEM(rootCAData)
	if succ != true {
		t.Fatal(succ)
	}

	tlsConfig := &tls.Config{
		RootCAs:    rootCAs,                          // 信任的根 CA 池（用于验证服务器证书）
		ServerName: "terminal.uat.planetpayment.com", // 服务器证书的域名（必须与证书的 CN 或 SAN 匹配）
		MinVersion: tls.VersionTLS12,                 // 禁用不安全的 TLS 版本
		// 禁用 InsecureSkipVerify（生产环境绝对不能开启！）
		//InsecureSkipVerify: true, // 开启后会跳过证书验证（不安全）
	}

	cTimeout := 3 * time.Second
	rTimeout := 30 * time.Second
	wTimeout := 30 * time.Second

	logger.Debugf(ctx, "gogo")
	for i := 0; i <= 4; i++ {
		ctx := context.WithValue(context.Background(), "trace_id", util.GenXid())
		go func() {
			c := network.NewTcpSslConn("terminal.uat.planetpayment.com:40860", cTimeout, rTimeout, wTimeout, tlsConfig)
			err = c.Open(ctx)
			if err != nil {
				t.Fatal(err)
			}
			bcd := "0094600010000002003020058020C0900200200000000000055500002700210226003750100439999991007D0810120000000323701F31313431313131313138383030303334343333332020200124AA17EAB7BF18034B0061000331325800044941022000064942463945410003494303000349440100034945000003494600000349470000034948000010494C0000702940000850"
			b, _ := hex.DecodeString(bcd)
			c.Writen(ctx, b)

			head, err := c.Readn(ctx, 2)
			if err != nil {
				t.Fatal(err)
			}

			slen := hex.EncodeToString(head)
			logger.Debugf(ctx, "slen: %s", slen)
			blen, err := strconv.ParseUint(slen, 16, 32)
			if err != nil {
				logger.Warnf(ctx, "err: %s", err.Error())
				return
			}
			logger.Debugf(ctx, "blen: %d", blen)
			data, err := c.Readn(ctx, int(blen))

			if err != nil {
				t.Fatal(err)
			}
			bcdData := hex.EncodeToString(data)
			logger.Debugf(ctx, "bcdData: %s", bcdData)
		}()
	}

	time.Sleep(10 * time.Second)

}
